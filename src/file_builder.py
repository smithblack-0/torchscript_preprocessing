"""
The proeprocessing process requires the creation
of temporary objects which can be checked
by inspect. This is handled by the codeBuilder
package

Objectives:

Create temporary files with boilerplate and debug information
Ensure these temporary files are accessable by inspect.
Ensure these temporary files are capable of producing sane debug information
"""

import inspect
import os
import re
import pathlib
import tempfile
import datetime
from typing import List

from src import errors
from src import rcb
from dataclasses import dataclass

boilerplate_template="""\
\"\"\"
This is an automatically generated 
file produces by preprocessing. This
file is designed to be run within
the namespace it was called in.

Do not edit this file.

DEBUG_INFO:

This file was created from a file located at: {path}
This file was created at time: {time}

The environmental variables present 
upon creation are:

{environmentals}
\"\"\"
"""


@dataclass
class CodeBlock:
    """
    A codeblock contains a representation of
    a chunk of code that belongs in a temporary
    file. Importantly, it also contains details on
    what code was being preprocessed, and why,
    allowing sane error handling
    """

    source: str #The source string
    error: Exception #An exception to associate with this string.

@dataclass
class ErrAssociation:
    """
    Tracks what part of the
    source are associated
    with which error to throw.
    """
    start_line: int
    end_line: int
    error: Exception
    def is_associated(self, lineno: int):
        """ Returns if a lineno is associated with this error"""
        return self.start_line <= lineno <= self.end_line


class CodeFile():
    """
    A manager for a temporary
    code file and associated error
    handling.

    --- objectives ---
    create temporary file with CodeBlock
    exhibit source code out of temporary file
    exhibit path of temporary file
    clean up afterwords (delete temp on GC)
    retrieve codeblock errors based on lineno
    """
    @property
    def name(self):
        return pathlib.Path(self.path).name
    @property
    def path(self):
        return self._path
    @property
    def read(self)->str:
        with open(self.path) as f:
            f.seek(0)
            return f.read()
    def fetch_err(self, lineno: int)->Exception:
    def __init__(self, source: List[CodeBlock]):
        errors: List[ErrAssociation] = []
        stringsource = ""
        lineno = 0
        for block in source:
            start = lineno
            sourcelines = block.source.split("\n")
            lineno += len(sourcelines)
            end = lineno
            errors.append(ErrAssociation(start, end, block.error))






        handle = tempfile.NamedTemporaryFile(mode="w",
                                                  suffix='.py',
                                                  delete=False)

        handle.write(source)
        self._path = handle.name
        handle.close()
        self.release = True
    def __del__(self):
        if self.release:
            os.remove(self.path)
class CodeFile():
    """
    A file manager for temporary
    code. Initialized with source code
    string. Cleans up after itself upon
    GC.

    Unless release is set to false, upon
    GC deletes the temporary file.
    """
    @property
    def name(self):
        return pathlib.Path(self.path).name
    @property
    def path(self):
        return self._path
    @property
    def contents(self)->str:
        with open(self.path) as f:
            f.seek(0)
            return f.read()
    def __init__(self, source: str):
        handle = tempfile.NamedTemporaryFile(mode="w",
                                                  suffix='.py',
                                                  delete=False)

        handle.write(source)
        self._path = handle.name
        handle.close()
        self.release = True
    def __del__(self):
        if self.release:
            os.remove(self.path)



class CodeBuilder:
    """
    A class responsible for collecting
    codeblocks together for synthesis.

    Contains templates, along with
    individual codeblocks
    """
    def __init__(self, start_template: str):
        self.template = start_template
        self.source: List[CodeBlock] = []
    def compile(self, **kwargs):
        """
        Compiles all the code into a source file. Routes kwargs
        into the matching templates.
        :param kwargs:
        :return:
        """
        pass


class CodeBuilder():
    """
     A location for building temporary
     code.

     Consists of boilerplate at the front indicating
     debug information, along with methods for
     adding code blocks on.

     When provided with an environment, the contents
     are written to a temporary file, then
     loaded as a module with the
     Collects together boilerplate, along
     with code entries.

     When called with an environment, the environment
     is cloned, all code runs in the new sandbox, and
     any environmental changes are returned as
     part of a new module. This module will then
     support inspection.

     Proper usage is to append source files
     """

    def __init__(self, retain_crashfiles=True):
        """
        :param retain_crashfiles: Does not delete the temporary files upon the raising of exceptions,
            allowing the user to inspect it.
        """
        self.retain = retain_crashfiles
        self.source: List[CodeBlock] = []
    def make_boilerplate(self, env: rcb.EnvProxy):
        """

        Makes the boilerplate commentary
        living at the front of each temporary
        file

        :param env: The environment
        :return: A string of commentary
        """


        frame = inspect.currentframe()
        path = frame.f_back.f_back.f_code.co_filename
        path = re.escape(path)

        time = datetime.datetime.now()
        vars = env.as_dict().keys()
        vars = [str(var) for var in vars]
        vars = "\n".join(vars)
        intro = boilerplate_template.format(path=path,
                                    time=time,
                                    environmentals=vars)
        return intro
    def append(self, source: str):
        self.source.append(source)
    def __call__(self, fetch: str, env: rcb.EnvProxy):
        """
        :param fetch: The name of the feature to get out of the source
        :param env: The environment to run the module in.
        :return: Whatever environmental parameter is named fetch.
        """

        #The following lines of code should have a little bit of explanation.
        #
        #We basically create a temporary source file, a temporary
        #environment, and then compile some bytecode while
        #telling python the source is coming from the temporary
        #file.
        #
        #This ensures inspect can track it down.
        #
        #Once this is done, we return the requested environmental variable
        #from the temporary sandbox.

        #Collect sources, and attach the boilerplate code.
        sources = [self.make_boilerplate(env)] + self.source
        sources = "\n".join(sources)
        file = TempCodeFile(sources)

        #Execute. Handle crashes
        #
        #Note that the sandbox maintains some side effects,
        #particularly anything resulting from modifying objects.
        #
        #It really just ensures that the global state is not directly
        #modified.
        partial_sandbox = env.copy()
        code = compile(file.contents, file.path, 'exec')
        try:
            exec(code, partial_sandbox.globals, partial_sandbox.locals)
        except Exception as err:
            if self.retain:
                file.release = False
            raise err

        #Fetch the desired item out of the sandboxed environment.
        return getattr(partial_sandbox, fetch)

