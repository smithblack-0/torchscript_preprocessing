"""
This module manages the creation and usage
of virtual code. Virtual code uses some
tricks of the import system to ensure
inspect is adequetely redirected into the
code that is being created.
"""
import os
import tempfile
from importlib.machinery import ModuleSpec
from typing import Callable, Any, Dict, Optional
import importlib
from importlib import util
from importlib.machinery import ModuleSpec
import random
import rcb



boilerplate_template="""\
\"\"\"
This is an automatically generated 
file produces by preprocessing. This
file is designed to be run within
the namespace it was called in.

Do not edit this file.

DEBUG_INFO:

This file was created from a file located at: {path}
This file was created at time: {time}

The environmental variables present 
upon creation are:

{environmentals}
\"\"\"
"""


class TempCodeFile():
    """
    A file manager for temporary
    code. Initialized with source code
    string. Cleans up after itself upon
    GC.
    """
    @property
    def path(self):
        return self.handle.name
    def __init__(self, source: str):
        self.handle = tempfile.NamedTemporaryFile(mode="a+",
                                                  suffix='.py',
                                                  delete=False)
        self.handle.write(source)
    def __del__(self):
        self.handle.close()
        os.remove(self.handle.name)

class CodeBuilder():
    """
     A location for building temporary
     code.

     Collects together boilerplate, along
     with code entries.

     When called with an environment, the environment
     is cloned, all code runs in the new sandbox, and
     any environmental changes are returned as
     part of a new module. This module will then
     support inspection.
     """

class TempCodeBuilder():


class mockModuleLoader(importlib.abc.InspectLoader):
    """
    Loads the virtual module, and
    returns features from it.
    """
    def __init__(self, source: str, env: rcb.EnvProxy):
        self.source = source
        self.env = env
    def create_module(self, spec: ModuleSpec):
        return None
    def get_source(self, fullname: str):
        return self.source
    def exec_module(self, module):
        print(module)
        exec(self.source, self.env.locals, self.env.globals)
        print(self.env.locals)
        print(self.env.globals)
        print(potato)
        return module

source = """\
print(random.randint(0, 5))

print("hello world")
potato = 3
"""
proxy = rcb.makeEnvFromFrame()
loader = mockModuleLoader(source, proxy)
spec = ModuleSpec("test", loader)
spec =  util.spec_from_loader("test", loader)
module = importlib.util.module_from_spec(spec)
spec.loader.exec_module(module)
print(dir(module))
